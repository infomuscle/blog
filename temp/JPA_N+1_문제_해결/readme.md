# [JPA] N+1 문제 해결



개인 이력서 웹사이트 JPA N+1 문제 해결



## 기

이력서 목적으로 웹사이트를 하나 띄워서 운영하고 있다.

오버스펙일 순 있겠지만 컨텐츠는 DB로 별도 분리해서 관리하고 있다.

처음 만들 당시에는 회사에서 JPA를 쓸 일이 없어 JPA로 만들어 봤는데,

딱히 공부를 했다기보단 이렇게 하니깐 CRUD가 되는군, 참 쉽다 요 정도로 사용만 했었다.



간만에 이력서 업데이트 겸 프로젝트 업데이트도 했는데 테스트 중에 문제를 발견했다.

![image1](./image1.png)

컨트롤러 한 번 호출했는데, 쿼리가 몇 개가 나가는거지.

지금이야 JPA 공부를 한 번 해둔 상태라, 어떤 문제인지 바로 알 수 있었다.

N+1이고만.



## 승

### N+1이란?

이건 사실 1+N 문제라고 하는 편이 정확하다.

N+1이라 하면, N개 조회를 하는데 1개가 더 나간다는 어감이다.

1번만 나가면 될 쿼리인데, 매핑된 데이터를 조회하기 위해 쿼리가 N번 더 나간다는 의미이다.

정확히는 1개 조회를 하는데, 거기에 1:N으로 조인된 N개 데이터에 대해 N번 쿼리가 나간단 의미이다.



### 언제 발생하지?

N+1은 1:N, 혹은 N:1 관계의 데이터를 조회할 때 발생한다.

![image2](./image2.png)

위 로그 이미지를 다시 봐보자.

1번은 내가 수행한 프로젝트 리스트를 조회하는 쿼리이다.

그럼 `PROJECT` 테이블에서 조건에 맞는 모든 데이터를 불러온다.

근데 이력서에는 프로젝트의 상세 설명이 있어야 내가 기여한 내역을 글만으로 더 잘 전달할 수 있을 것이다.

그래서 프로젝트에서 내가 진행한 구체적인 업무를 적은 `PROJECT_DETAIL`이란 테이블이 있다.

프론트에서는 이렇게 가져온 각 프로젝트에 매핑된 상세 내용을 목록으로 보여주도록 되어있다.



그림으로 표현하면 다음과 같은 구조다(컬럼은 일부 생략했다).

![image3](/Users/bokeun/Desktop/Projects/blog/temp/JPA_N+1_문제_해결/image3.png)





반면에 엔티티간의 관계, 즉 객체 관계는 다음 그림과 같다.

![image4](/Users/bokeun/Desktop/Projects/blog/temp/JPA_N+1_문제_해결/image4.png)





`Project`가 여러개의 `ProjectDetail`을 리스트로 갖고 있다.

이 때 `Project`를 조회한다고 해보자.

가져온 `Project`의 수만큼 `ProjectDetail`을 또 호출해서, 각 `Project`에 매핑된 `ProjectDetail` 리스트를 가져온다.

즉 위 로그 이미지에서 1번 쿼리는 `PROJECT`를 조회하는 `select * from PROJECT` 쿼리이다.

그리고 화살표 친 박스의 쿼리들은 조회된 각 `PROJECT` 데이터와 연결된 `PROJECT_DETAIL`의 데이터를 조회하는,

 `select * from PROJECT_DETAIL where PROJECT_ID = #{id} `이다.

여기서 박스 안에 7개의 쿼리가 있으니깐 `select * from PROJECT`는 7개의 데이터를 가져왔다는 것을 알 수 있다.



2번은 N:1의 경우다.

내가 경험해본 기술들을 `SKILL` 테이블에서 조회하는 쿼리다.

근데 내가 각 기술을 알고있는 수준을 설명하기 위해 `SKILL_PROFICIENCY`라는 테이블을 별도로 만들었다.

각 `SKILL` 데이터는 `SKILL_PROFICIENCY`의 `ID`만 들고 있고, 숙련도의 상세 내용은 조인으로 가져온다.

테이블과 객체 관계는 아래와 같다.

![image5](/Users/bokeun/Desktop/Projects/blog/temp/JPA_N+1_문제_해결/image5.png)

![image6](/Users/bokeun/Desktop/Projects/blog/temp/JPA_N+1_문제_해결/image6.png)

그럼 2번 쿼리는 `SKILL` 테이블에서 데이터를 불러오는 쿼리고,

화살표 친 3개의 쿼리는 `SKILL_PROFICIENCY`에서 데이터를 불러오는 쿼리임을 알 수 있다.

다만 이 경우는 `SKILL`에서 조회한 데이터가 3개라고 할 수 없다.

예를 들어서 내 기술(숙련도)가 자바(3), 오라클(2), PostgreSQL(2), JPA(3), Kafka(1)이라고 가정해보자.

5개의 데이터를 불러왔고, 각 데이터에 매핑된 숙련도를 가져와야 한다.

하지만 JPA의 영속성 컨텍스트는 한 번 가져온 데이터에 대해서는 또 쿼리를 날리지 않게 해준다.

즉 자바에 매핑된 숙련도 `select * from SKILL_PROFICIENCY where ID = 3`으로 한 번 `SkillProficiency`를 조회한 다음에,

JPA의 숙련도를 조회할 때는 DB를 거치지 않고 영속성 컨텍스트에서 바로 같은 엔티티를 가져오는 것이다.

여기서 숙련도는 1, 2, 3 세개기 때문에 박스 안의 쿼리는 3번만 날라간 것을 확인할 수 있다.



### 왜 발생하지?

그럼 N+1은 대체 왜 발생할까?

