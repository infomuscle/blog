# [Database] 데이터베이스의 실행 계획

데이터베이스는 J입니다.

쿼리로 특정 데이터를 검색하라는 명령을 받으면 일단 무작정 찾아보지 않고,

여러 검색 방법을 비교하고 가장 효율적으로 선택할 수 있는 방법을 찾습니다.

그리고 그 방법대로 명령을 수행합니다.

이 방법을 실행계획, 그리고 실행계획을 세우는 주체를 옵티마이저라고 부릅니다.

<br>

## 실행 계획과 옵티마이저

실행계획은 **데이터베이스가 SQL을 실행하려 데이터를 추출할 때 옵티마이저가 수립하는 작업 절차**입니다.

PLAN_TABLE에 저장이 되며, EXPLAIN PLAN으로 확인할 수 있습니다.

DBeaver 같은 툴에서는 좀 더 편하고 시각화된 실행계획을 볼 수 있도록 지원하기도 합니다.

<br>

### 해석 순서

실행계획을 읽는 방법은 DFS와 같다고 할 수 있습니다.

트리 형태로 실행계획이 주어진다면 가장 좌측 아래까지 타고 들어갑니다.

만약 자식 노드가 없다면 읽고 부모 노드로 올라갑니다.

부모 노드에 남은 자식 노드가 있다면 다시 그 자식 노드를 타고 들어가 같은 방식으로 반복합니다.

부모 노드에 남은 자식 노드가 없다면 부모 노드를 읽고 부모 노드의 부모 노드로 올라가고요.

<br>

### 옵티마이저의 종류

옵티마이저는 어떻게 실행 계획을 수립할까요?

옵티마이저는 아래 2가지 종류로 나눌 수 있습니다.

<br>

#### 1. 비용 기반 옵티마이저

옵티마이저는 기본적으로 통계 정보를 활용하여 비용 기반으로 실행계획을 수립합니다.

활용되는 통계 정보는 오브젝트 통계와 시스템 통계입니다.

이 통계 정보로 예상 소요시간이나 자원의 사용량을 최소화할 수 있는 방식으로 실행 계획을 수립합니다.

하지만 통계 정보가 부적절한 경우 오히려 성능 저하가 발생할 수도 있습니다.

<br>

#### 2. 규칙 기반 옵티마이저

규칙 기반 옵티마이저는 아래와 같은 우선순위를 따릅니다.

| 우선순위 | 설명                                                         |
| -------- | ------------------------------------------------------------ |
| 1        | ROWID를 사용한 단일 행인 경우                                |
| 2        | 클러스터 조인에 의한 단일 행인 경우                          |
| 3        | 유일하거나 기본 키를 가진 해시 클러스터 키에 의한 단일 행인 경우 |
| 4        | 유일하거나 기본 키에 의한 당일 행인 경우                     |
| 5        | 클러스터 조인인 경우                                         |
| 6        | 해시 클러스터 조인인 경우                                    |
| 7        | 인덱스 클러스터 키인 경우                                    |
| 8        | 복합 컬럼 인덱스인 경우                                      |
| 9        | 단일 컬럼 인덱스인 경우                                      |
| 10       | 인덱스가 구성된 컬럼에서 제한된 범위를 검색하는 경우         |
| 11       | 인덱스가 구성된 컬럶에서 무제한 범위를 검색하는 경우         |
| 12       | 정렬-병합 조인인 경우                                        |
| 13       | 인덱스가 구성된 컬럼에서 MAX 혹은 MIN을 구하는 경우          |
| 14       | 인덱스가 구성된 컬럼에서 ORDER BY를 실행하는 경우            |
| 15       | 전체 테이블을 스캔하는 경우                                  |

<br>

## 스캔

스캔은 데이터를 읽는 작업입니다.

이 때 가장 효율적으로 읽기 위한 전략이 있는데, 특히 아래 3가지 방법이 중요합니다.

- FULL TABLE SCAN
- ROWID SCAN
- INDEX SCAN

인덱스에 관해서는 별도의 포스팅으로 정리하도록 하고,

우선 각 스캔 방법이 어떤 특징을 갖고 있는지 확인해보겠습니다.

<br>

### FULL TABLE SCAN

테이블의 모든 데이터를 읽습니다.

데이터 양이 많아질수록 시간이 오래 걸리지만, FULL TABLE SCAN이 항상 나쁜 것은 아닙니다.

테이블에 데이터가 적어서 인덱스를 타는 시간보다 그냥 다 훑어버리는 게 빠를 수도 있습니다.

또는 추출 데이터가 엄청 많아도 FULL TABLE SCAN이 유리할 수도 있습니다.

FULL TABLE SCAN을 타는 경우는 다음과 같이 정리할 수 있습니다.

- 조건절의 컬럼에 인덱스가 없는 경우
- 조건절의 컬럼에 인덱스가 있지만, 해당 데이터가 많아 FULL TABLE SCAN이 낫다고 옵티마이저가 판단하는 경우
- 조건절의 컬럼에 인덱스가 있지만, 테이블의 데이터가 적어 FULL TABLE SCAN이 낫다고 옵티마이저가 판단하는 경우
- 테이블 생성시 DEGREE 속성 값이 크게 설정되어 있는 경우

<br>

### ROWID SCAN

단일 행 접근이 매우 빠릅니다.

ROWID SCAN을 탈 수 있는 상황이라면 사용하는 것이 좋다.

- 조건절에 ROWID를 직접 명시하는 경우
- INDEX SCA을 통해 ROWID를 추출한 후 테이블에 접근할 경우

<br>

### INDEX SCAN

- INDEX UNIQUE SCAN
  - PK나 UNIQUE INDEX를 구성하는 모든 컬럼이 조건에 "="로 명시된 경우
- INDEX RANGE SCAN
  - LIKE나 BETWEEN처럼 특정 범위를 조회할 때 사용합니다.
  - 데이터 양이 적을 경우 비용 비교를 통해 FULL SCAN을 탈 수도 있습니다.
  - 리프 블록의 특정 범위를 스캔합니다.
- INDEX FULL SCAN
  - 인덱스의 리프 블록을 처음부터 끝까지 모두 스캔합니다.
  - ORDER BY / GROUP BY의 모든 컬럼이 인덱스의 전체, 또는 일부로 정의된 경우
  - 정렬이 필요한 명령에서 INDEX ENTRY를 순차적으로 읽는 방식으로 처리된 경우
- INDEX SKIP SCAN
  - 결합 인덱스의 선행 컬럼이 WHERE절에 포함된 경우
  - 옵티마이저가 FULL TABLE SCAN보다 낫다고 판단하는 경우
- INDEX FAST FULL SCAN
  - FULL TABLE SCAN을 하지 않고도 INDEX FAST FULL SCAN으로 원하는 데이터를 추출할 수 있고 추출된 데이터의 정렬이 필요 없으며 결합 인덱스를 구성하는 컬럼 중에 최소 한 개 이상은 NOT NULL인 경우
- INDEX JOIN
  - 추출하고자 하는 데이터가 조인하는 인덱스에 모두 포함되어 있고 추출하는 데이터의 정렬이 필요없는 경우

<br>

## 조인