# [Algorithm] 2019 카카오 블라인드 테스트 문제풀이 - 실패율

![2019 카카오 블라인드 테스트](./image.jpeg)
<!-- [##_Image|kage@cgGpEl/btqZn1tqZrF/MCYgvJB7TGL6JY1OHw43yK/img.jpg|alignCenter|width="100%"|_##] -->

## 문제

```text
슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.

이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.

실패율은 다음과 같이 정의한다.
스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수
전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.
```

[프로그래머스 문제 바로가기](https://programmers.co.kr/learn/courses/30/lessons/42889)


## 풀이

```python
def solution(N, stages):
    # {스테이지: 플레이어 수} 포맷의 딕셔너리 생성
    players = {}
    for stage in stages:
        if stage not in players:
            players[stage] = 0
        players[stage] += 1

    # 모든 스테이지를 통과한 플레이어 수 세팅
    total = players.get(N + 1, 0)

    # N번 스테이지부터 1번 스테이지까지 실패율 계산
    fail_rates = {}
    for i in range(N, 0, -1):

        # i번 스테이지에 플레이어가 있을 경우 해당 스테이지를 통과한 전체 플레이어 수에 더한 후 실패율 계산
        if i in players:
            total += players[i]
            fail_rates[i] = players[i] / total
        # i번 스테이지에 플레이어가 없을 경우 실패율은 0
        else:
            fail_rates[i] = 0

    # 실패율(Value), 스테이지(Key)의 우선순위로 정렬한 리스트에서 스테이지만 뽑은 리스트 생성
    answer = [item[0] for item in sorted(fail_rates.items(), key=lambda x: (-x[1], x[0]))]

    return answer
```

각 플레이어가 위치한 스테이지의 리스트인 `stages`와 전체 스테이지의 개수 `N`을 받아,

각 스테이지에 위치한 플레이어 수 / 스테이지에 있거나 통과한 플레이어의 수를 구하는 문제다.

즉 필요한 것은 `각 스테이지에 위치한 플레이어 수`와 ` 스테이지에 있거나 통과한 플레이어의 수`이다.

따라서 문제 해결 로직두 2단계로 나뉜다.

1. 스테이지별 플레이어 수 구하기
2. 각 스테이지를 통과하거나, 현재 위치한 플레이어 수 구하기

#### STEP 1

빈 딕셔너리인 `players`를 만든다. 반복문으로 `stages`에 있는 각 `stage`를 돌며 각 스테이지별 플레이어 수를 저장한다.

#### STEP 2

먼저 모든 스테이지를 통과한 플레이어 수를 구해야 한다. `total` 변수에 N+1 스테이지, 즉 모든 스테이지를 통과한 플레이어 수의 값을 세팅해준다. 만약 모든 스테이지를 통과한 플레이어가 없다면 `players`에 `N+1` 키는 없을 것이므로, 기본값으로 0을 세팅한다.

그리고 N번 스테이지부터 역으로 실패율을 체크한다. 만약 `stages`에 i 원소, 즉 i번 스테이지에 있는 플레이어가 없었다면 `players`에 `i` 키는 없으므로 함부로 접근하다간 에러가 나기 쉽다. 따라서 i가 `players`에 있는지 없는지 체크를 해준다.

1) i가 있을 경우
	- `total`에 `players[i]`를 더하면 `total`은 현재 스테이지를 통과한 플레이어 + 현재 스테이지에 있는 플레이어, 즉 도달한 플레이어가 된다.
	- 그리고 현재 스테이지에 있는 플레이어 수와 나눈 값, 즉 실패율을 `fail_rates` 딕셔너리에 저장한다.
2) i가 없을 경우
	- 실패율은 어차피 0이다. 

각 스테이지별 실패율이 `fail_rates`에 저장된다. 그리고 우선순위대로 정렬을 해준다. 제한사항은 다음과 같았다.

1. 실패율이 높은 스테이지부터 내림차순
2. 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지 먼저


> [MEMO]
> 딕셔너리의 items() 메소드는 (Key, Value)의 튜플을 리턴해준다.

> [MEMO]
> sorted()로 정렬시 다중조건은 `key=lambda x:(조건1, 조건2)` 식으로 줄 수 있다.

실패율인`x[1]`에 대해서 내림차순, 그리고 스테이지 번호인 `x[0]`에 대해서 오름차순으로 정렬한다. 정렬된 튜플의 리스트에서, 각 튜플의 0번째 원소, 즉 스테이지 번호만 추출한 리스트를 리턴한다. 

> 블로그 포스팅을 하면서 문제를 완전 새로 풀었다. 이전보다 속도도 개선하고 코드도 훨씬 깔끔하고 이해하기 좋아졌다.
